# Eco-Bot Copilot Instructions

This file is auto-generated by Eco-Bot to provide ecological and economic context
to AI coding assistants. Place this in `.github/copilot-instructions.md` in your repository.

## Project Eco-Profile

<!-- eco-bot:metrics-start -->
**Last Analysis**: {{timestamp}}
**Health Index**: {{health_index}}/100 (Grade: {{grade}})

| Metric | Score | Trend |
|--------|-------|-------|
| Ecological | {{eco_score}} | {{eco_trend}} |
| Economic | {{econ_score}} | {{econ_trend}} |
| Quality | {{quality_score}} | {{quality_trend}} |
<!-- eco-bot:metrics-end -->

## Ecological Code Guidelines

When writing or reviewing code in this repository, always consider these principles:

### 1. Carbon Efficiency

**Prefer algorithms with lower computational complexity.**

- Before writing a loop, ask: "Is there a more efficient algorithm?"
- Avoid O(n²) or worse when O(n log n) or O(n) alternatives exist
- Consider the energy cost of your code running millions of times

```
# BAD: O(n²) nested loops
for item in items:
    for other in items:
        if item.matches(other): ...

# GOOD: O(n) with hash lookup
item_map = {item.key: item for item in items}
for item in items:
    if item.key in item_map: ...
```

### 2. Energy Patterns

**Avoid busy-waiting; prefer event-driven designs.**

```
# BAD: Busy waiting (wastes CPU cycles)
while not ready:
    time.sleep(0.1)

# GOOD: Event-driven (sleeps until needed)
event.wait()
```

**Use connection pooling for external resources.**

```
# BAD: Create new connection each time
def get_data():
    conn = create_connection()
    result = conn.query()
    conn.close()
    return result

# GOOD: Reuse connections
pool = ConnectionPool(max_size=10)
def get_data():
    with pool.get() as conn:
        return conn.query()
```

### 3. Resource Allocation

**Release resources promptly; use context managers.**

```python
# GOOD: Context manager ensures cleanup
with open(file) as f:
    data = f.read()
# File automatically closed
```

**Prefer lazy evaluation for large datasets.**

```python
# BAD: Loads all into memory
all_results = [process(x) for x in huge_list]

# GOOD: Generator (lazy evaluation)
def results():
    for x in huge_list:
        yield process(x)
```

### 4. Pareto Optimality

When making trade-offs, document the decision.

**Always consider multiple objectives:**
- Performance vs. Readability
- Memory vs. Speed
- Simplicity vs. Flexibility

```python
# Document trade-off decisions
# TRADE-OFF: Using dict for O(1) lookup increases memory by ~2x
# but reduces query time from O(n) to O(1). For our use case
# with ~10K items and frequent queries, this is Pareto optimal.
lookup_table = build_lookup_table(items)
```

## Current Hotspots

<!-- eco-bot:hotspots-start -->
These areas have been flagged for eco/econ attention:

{{#each hotspots}}
- **{{this.file}}**: {{this.reason}} (Score: {{this.score}})
{{/each}}
<!-- eco-bot:hotspots-end -->

## Best Practices for This Codebase

<!-- eco-bot:practices-start -->
Based on analysis of this repository:

{{#each best_practices}}
1. **{{this.practice}}**: {{this.description}}
   - Expected impact: {{this.carbon_impact}}% carbon, {{this.energy_impact}}% energy
{{/each}}
<!-- eco-bot:practices-end -->

## When Suggesting Code

1. **Default to efficient patterns**: Suggest the eco-friendly option first
2. **Explain trade-offs**: When there's a choice, explain the eco/econ implications
3. **Flag anti-patterns**: Warn about patterns known to have high eco impact
4. **Recommend testing**: Suggest profiling for performance-critical code

## Quick Reference: Eco Patterns

| Pattern | Carbon Impact | Energy Impact | When to Use |
|---------|--------------|---------------|-------------|
| Memoization | -25% | -20% | Expensive repeated calculations |
| Connection Pooling | -15% | -20% | Database/API access |
| Lazy Evaluation | -10% | -15% | Large data processing |
| Event-Driven | -5% | -30% | Waiting for external events |
| Batching | -15% | -15% | Multiple I/O operations |

## Anti-Patterns to Avoid

| Anti-Pattern | Problem | Alternative |
|--------------|---------|-------------|
| Busy Waiting | Wastes CPU cycles | Event-driven waiting |
| Premature Optimization | Adds complexity | Profile first, optimize hotspots |
| N+1 Queries | Excessive DB calls | Batch loading, JOINs |
| Unbounded Caching | Memory bloat | LRU cache with size limits |
| Polling | Constant resource use | Webhooks, SSE, WebSockets |

---

*This file is maintained by [Eco-Bot](https://github.com/hyperpolymath/eco-bot).
Last updated: {{timestamp}}*
