// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var tokenCache = {};

function pemToArrayBuffer(pem) {
  var pemContents = pem.replace(/-----BEGIN (?:RSA )?PRIVATE KEY-----/g, "").replace(/-----END (?:RSA )?PRIVATE KEY-----/g, "").replace(/\\s/g, "");
  var binaryStr = globalThis.atob(pemContents);
  var len = binaryStr.length;
  var bytes = new Uint8Array(len);
  for(var i = 0; i < len; ++i){
    var charCode = binaryStr.charCodeAt(i) | 0;
    bytes[i] = charCode;
  }
  return bytes.buffer;
}

function base64UrlEncode(data) {
  var len = data.length;
  var binaryStr = "";
  for(var i = 0; i < len; ++i){
    var $$byte = data[i];
    binaryStr = binaryStr + String.fromCharCode($$byte);
  }
  return globalThis.btoa(binaryStr).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function base64UrlEncodeString(str) {
  return globalThis.btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

async function generateJWT(appId, privateKeyPem) {
  var nowSeconds = Date.now() / 1000.0;
  var header = Js_dict.fromArray([
        [
          "alg",
          "RS256"
        ],
        [
          "typ",
          "JWT"
        ]
      ]);
  var headerB64 = base64UrlEncodeString(JSON.stringify(header));
  var payload = Js_dict.fromArray([
        [
          "iss",
          appId
        ],
        [
          "iat",
          nowSeconds - 60.0
        ],
        [
          "exp",
          nowSeconds + 600.0
        ]
      ]);
  var payloadB64 = base64UrlEncodeString(JSON.stringify(payload));
  var message = headerB64 + "." + payloadB64;
  try {
    var keyBuffer = pemToArrayBuffer(privateKeyPem);
    var encoder = new (globalThis.TextEncoder)();
    var key = await globalThis.crypto.subtle.importKey("pkcs8", keyBuffer, {
          name: "RSASSA-PKCS1-v1_5",
          hash: "SHA-256"
        }, false, ["sign"]);
    var messageBytes = encoder.encode(message);
    var signatureBuffer = await globalThis.crypto.subtle.sign({
          name: "RSASSA-PKCS1-v1_5"
        }, key, messageBytes);
    var signatureBytes = new (globalThis.Uint8Array)(signatureBuffer);
    var signatureB64 = base64UrlEncode(signatureBytes);
    return {
            TAG: "Ok",
            _0: message + "." + signatureB64
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    var jsExn = Caml_js_exceptions.as_js_exn(exn);
    var msg = jsExn !== undefined ? Belt_Option.getWithDefault(Caml_option.valFromOption(jsExn).message, "Unknown error") : "Unknown error";
    return {
            TAG: "Error",
            _0: "Failed to generate JWT: " + msg
          };
  }
}

async function getInstallationToken(jwt, installationId) {
  var cacheKey = String(installationId);
  var cached = Js_dict.get(tokenCache, cacheKey);
  if (cached !== undefined && cached.expiresAt > Date.now() + 60000.0) {
    return {
            TAG: "Ok",
            _0: cached
          };
  }
  try {
    var response = await globalThis.fetch("https://api.github.com/app/installations/" + cacheKey + "/access_tokens", {
          method: "POST",
          headers: {
            Authorization: "Bearer " + jwt,
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "User-Agent": "oikos-bot"
          }
        });
    if (response.ok) {
      var json = await response.json();
      var obj = Js_json.decodeObject(json);
      if (obj === undefined) {
        return {
                TAG: "Error",
                _0: "Invalid JSON response"
              };
      }
      var t = Js_dict.get(obj, "token");
      var token = t !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(t), "") : "";
      var e = Js_dict.get(obj, "expires_at");
      var expiresAtStr = e !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(e), "") : "";
      if (token === "") {
        return {
                TAG: "Error",
                _0: "No token in response"
              };
      }
      var expiresAtDate = new Date(expiresAtStr);
      var expiresAt = expiresAtDate.getTime();
      var installToken = {
        token: token,
        expiresAt: expiresAt
      };
      tokenCache[cacheKey] = installToken;
      return {
              TAG: "Ok",
              _0: installToken
            };
    }
    var status = response.status;
    var body = await response.text();
    return {
            TAG: "Error",
            _0: "GitHub API error " + String(status) + ": " + body
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    var jsExn = Caml_js_exceptions.as_js_exn(exn);
    var msg = jsExn !== undefined ? Belt_Option.getWithDefault(Caml_option.valFromOption(jsExn).message, "Unknown error") : "Unknown error";
    return {
            TAG: "Error",
            _0: "Failed to get installation token: " + msg
          };
  }
}

function extractInstallationId(payload) {
  var obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return ;
  }
  var inst = Js_dict.get(obj, "installation");
  if (inst === undefined) {
    return ;
  }
  var instObj = Js_json.decodeObject(inst);
  if (instObj === undefined) {
    return ;
  }
  var id = Js_dict.get(instObj, "id");
  if (id === undefined) {
    return ;
  }
  var num = Js_json.decodeNumber(id);
  if (num !== undefined) {
    return num | 0;
  }
  
}

async function getAuthToken(config, payload) {
  var match = config.githubAppId;
  var match$1 = config.githubPrivateKey;
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "GitHub App credentials not configured"
          };
  }
  if (match$1 === undefined) {
    return {
            TAG: "Error",
            _0: "GitHub App credentials not configured"
          };
  }
  var installationId = extractInstallationId(payload);
  if (installationId === undefined) {
    return {
            TAG: "Error",
            _0: "No installation ID in payload"
          };
  }
  var jwtResult = await generateJWT(match, match$1);
  if (jwtResult.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: jwtResult._0
          };
  }
  var tokenResult = await getInstallationToken(jwtResult._0, installationId);
  if (tokenResult.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: tokenResult._0.token
          };
  } else {
    return {
            TAG: "Error",
            _0: tokenResult._0
          };
  }
}

export {
  tokenCache ,
  pemToArrayBuffer ,
  base64UrlEncode ,
  base64UrlEncodeString ,
  generateJWT ,
  getInstallationToken ,
  extractInstallationId ,
  getAuthToken ,
}
/* No side effect */
